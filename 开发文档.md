## Vue3 与 Vue2 的区别介绍
Vue3新增设计：
+ **模块拆分**：Vue3 源码采用 menorepo 方式进行管理，将模块拆分到 packages 中
+ Vue3 采用 **TS** 开发，增强类型检测。Vue2 采用 flow
+ Vue3 的性能优化，支持 **Tree-Shaking** ，不使用就不会打包
+ 允许**自定义渲染器**，扩展能力强。
+ Vue3 后期引入 **RFC**（Request For Comments 意即“请求评论”），使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)，记录了很多基于讨论实现的功能

Vue3 内部代码优化：
+ Vue2 采用 `defineProperty` 进行对象的数据劫持，有性能问题和缺陷；**Vue3 采用 `Proxy` 进行数据劫持**。
+ **Vue3 中对模板编译进行了优化**，编译时生成了 Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点
+ **Vue3 采用 composition API 进行组织功能**，解决反复横跳，优化逻辑复用（优化 `mixin` 带来的数据来源不清晰、命名冲突等），相比 options API 类型推断更加方便
+ **Vue3 增加了 `Fragment`、`Teleport`、`Suspense` 组件**

## Vue3 架构分析
### 1. Monorepo 介绍
`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库（repo）中管理多个包/模块（packages）。
+ 一个仓库可以维护多个模块，不用到处找仓库
+ 方便版本管理和依赖管理，模块之间的引用，调用都非常方便

> 缺点：仓库体积会变大

### 2. Vue3 项目结构
在 [vue3源码](https://github.com/vuejs/core/tree/main) 中可以看到，`packages`中一共有十几个模块：
+ `reactivity`：响应式系统
+ `runtime-core`：与平台无关的运行时核心（可以创建针对特定平台的运行时 - 自定义渲染器）
+ `runtime-dom`：针对浏览器的运行时（包括 DOM API、属性、事件等）
+ `runtime-test`：用于测试的运行时
+ `server-renderer`：用于服务端渲染
+ `compiler-core`：与平台无关的编译器核心
+ `compiler-dom`：针对浏览器的编译模块
+ `compiler-ssr`：针对服务端渲染的编译模块
+ `compiler-sfc`：针对单文件解析
+ `size-check`：用来测试代码体积
+ `template-explorer`：用于调试编译器输出的开发工具
+ `shared`：多个包之间共享的内容
+ `vue`：完整版本，包括浏览器的运行时和编译器
+ ...

`vue` 包的核心模块如下：
```
                          +-------------------+
                          |                   |
                          | @vue/compiler-sfc |
                          |                   |
                          +-----+--------+----+
                                |        |
                                v        v
              +-------------------+    +--------------------+
              |                   |    |                    |
     +------->| @vue/compiler-dom +--->| @vue/compiler-core |
     |        |                   |    |                    |
+----+----+   +-------------------+    +--------------------+
|         |
|   vue   |
|         |
+----+----+   +------------------+    +-------------------+    +-----------------+
     |        |                  |    |                   |    |                 |
     +------->| @vue/runtime-dom +--->| @vue/runtime-core +--->| @vue/reactivity |
              |                  |    |                   |    |                 |
              +------------------+    +-------------------+    +-----------------+
```

## 搭建开发环境
1. 创建文件夹 `mini-vue3-zf-pnpm`，并初始化项目
    ```
    pnpm init
    ```
2. 创建 `packages/reactivity/src/index.ts`、`packages/shared/src/index.ts` 两个文件夹
3. 创建 `.npmrc` 配置文件
    ```shell
    # pnpm安装vue时，默认不会将vue依赖的包展平到 node_modules 下，导致项目中无法使用vue的依赖
    # 通过以下配置将 vue 依赖的包展平到 node_modules 下
    shamefully-hoist = true
    ```
4. 创建 `pnpm-workspace.yaml`，定义工作空间的根目录
   ```yaml
   packages:
    - "packages/*"
   ```
5. 安装 `esbuild`、`typescript`、`minimist`（` minimist` 是一个专门用于处理Node.js启动参数的库）
   ```
   pnpm install esbuild typescript minimist -D -w
   ```
6. 初始化 typescript 配置文件
   ```
   pnpm tsc --init
   ```
   ```json
    {
        "compilerOptions": {
            "outDir": "dist", // 输出的目录
            "sourceMap": true,  // 采用 sourcemap
            "target": "es2016", // 目标语法
            "module": "esnext", // 模块格式
            "moduleResolution": "node", // 解析模块的方式
            "strict": false,  // 严格模式
            "resolveJsonModule": true,  // 解析json模块
            "esModuleInterop": true,  // 允许通过es6语法引入 commonjs 模块
            "jsx": "preserve",  // jsx 不转义
            "lib": ["esnext", "dom"]  // 支持的类库：esnext和dom
        }
    }
   ```
7. 进入 reactivity 模块，初始化子项目
   ```
   cd packages
   cd reactivity
   pnpm init
   ```
   修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/reactivity",
        "version": "1.0.0",
        "description": "",
        "module": "dist/reactivity.esm-bundler.js",
        "unpkg": "dist/reactivity.global.js",
        "buildOptions": {
            "name": "VueReactivity",
            "formats": [
                "esm-browser",
                "esm-bundler",
                "cjs",
                "global"
            ]
        }
    }
   ```
   > formats 为自定义的需要打包的格式：
   > + `global`：立即执行函数的格式，会暴露全局对象
   > + `esm-browser`：在浏览器中使用的格式，内联所有的依赖项
   > + `esm-bundler`：在构建工具中使用的格式，不提供 `.prod` 格式，在构建应用程序时会被构建工具一起进行打包压缩
   > + `cjs`：在node中使用的格式，例如服务端渲染
8. 同理，也进入 shared 模块，修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/shared",
        "version": "1.0.0",
        "module": "dist/shared.esm-bundler.js",
        "buildOptions": {
            "formats": [
                "esm-bundler",
                "cjs"
            ]
        }
    }
   ```
9. 在 `reactivity` 模块安装 `shared` 模块的依赖：
    ```
    pnpm install @vue/shared@workspace --filter @vue/reactivity
    ```
10. 在 `tsconfig.json` 中配置路径别名：
    ```json
    "baseUrl": ".",
    "paths": {
      "@vue/*": ["packages/*/src"]
    }
    ```
11. 对模块进行打包
    + 在根`package.json`中添加命令：`"dev": "node scripts/dev.js reactivity -f esm"`
    + 创建 `scripts/dev.js`：
        ```js
        const { build } = require("esbuild");
        const path = require("path");
        const args = require("minimist")(process.argv.slice(2)); // { _: [ 'reactivity' ], f: 'esm' }

        // 打包的模块是哪个
        const target = args._[0] || "reactivity";
        // 打包的格式是什么
        const format = args.f || "global";
        // 读取模块的 package.json 文件
        const pkg = require(path.resolve(
            __dirname,
            `../packages/${target}/package.json`
        ));
        // 输出格式：把 global 改成 iife
        const outputFormat = format.startsWith("global")
            ? "iife"
            : format === "cjs"
            ? "cjs"
            : "esm";
        // 输出的路径
        const outfile = path.resolve(
            __dirname,
            `../packages/${target}/dist/${target}.${format}.js`
        );

        // 使用esbuild打包
        build({
            entryPoints: [path.resolve(__dirname, `../packages/${target}/src/index.ts`)], // 入口
            outfile, // 出口
            bundle: true, // 是否打包到一起
            sourcemap: true, // 是否生成sourcemap文件（.map 结尾）
            format: outputFormat, // 打包的格式
            globalName: pkg.buildOptions?.name, // 打包的全局名称
            platform: format === "cjs" ? "node" : "browser", // 平台
            watch: {
                // 监控文件变化
                onRebuild(error) {
                if (!error) {
                    console.log("rebuild~~~");
                }
                },
            },
        }).then(() => {
            console.log("watching~~~");
        });
        ```

## reactivity
### reactive
```js
// reactive.ts
import { isObject } from "@vue/shared";
import { mutableHandlers } from "./baseHandlers";
export const enum ReactiveFlags {
    IS_REACTIVE = "__v_isReactive",
}
const reactiveMap = new WeakMap(); // 使用 WeakMap 防止内存泄漏
export function reactive(target) {
    // 1. reactive 只代理对象
    if (!isObject(target)) {
        return target;
    }
    // 2. 如果已经被代理过，则直接返回
    // 取 target[ReactiveFlags.IS_REACTIVE] 时，如果target已经被代理过，则会走到get函数，返回true
    if (target[ReactiveFlags.IS_REACTIVE]) {
        return target;
    }
    // 3. 不重复代理同一对象
    const existProxy = reactiveMap.get(target);
    if (existProxy) {
        return existProxy;
    }
    // 4. 创建代理
    const proxy = new Proxy(target, mutableHandlers);
    reactiveMap.set(target, proxy); // target -> proxy 的映射表
    return proxy;
}
```
```js
// baseHandlers.ts
import { ReactiveFlags } from "./reactive";
export const mutableHandlers = {
    // receiver 是当前的代理对象
    get(target, key, receiver) {
        // 通过下列判断，解决不重复代理已经经过代理的对象
        if (ReactiveFlags.IS_REACTIVE === key) {
            return true;
        }
        /**
        * 【问题描述】为何不能直接通过 target[key] 取值？
        * 现有一个对象person：
        * let person = {
        *    name: 'jw',
        *    get aliasName() {
        *        return 'alias' + this.name
        *    }
        * }
        * 当通过 person.aliasName 取值时，内部的 this.name （this指向person）是通过 person.name 读取的，不会触发响应式；
        * 而改成 Reflect.get(target, key, receiver) 后，this 指向 receiver，this.name 即 personProxy.name，依然会触发响应式；
        */
        track(target, key);
        return Reflect.get(target, key, receiver); // 【使用 Reflect.get 处理了 target 内部的 this 指向问题】
    },
    set(target, key, value, receiver) {
        let oldValue = target[key];
        const r = Reflect.set(target, key, value, receiver); // Reflect.set 返回一个boolean值
        if (oldValue !== value) {
            trigger(target, key, value, oldValue);
        }
        return r;
    },
};
```

### effect && cleanupEffect
```js
function cleanupEffect(effect) {
  // 每次执行effect之前，都应该将该effect从deps所有属性的dep中清理出去，以及清空effect的deps数组
  let { deps } = effect;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
export let activeEffect;
export class ReactiveEffect {
  public fn;
  public active = true;
  public deps = [];
  public parent = undefined;
  constructor(fn) {
    this.fn = fn;
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    // 通过设置parent属性，确保在嵌套effect中activeEffect的准确性
    try {
      this.parent = activeEffect;
      activeEffect = this;
      /**
       * 【意料之外的重新渲染】：每次触发 trigger 重新执行effect.run()，此时effect的依赖项可能发生变化（可能会删除之前的依赖或新增新的依赖），如果之前的依赖被删掉了，那么就需要清除之前收集的依赖，不然当该依赖变化时会重新执行effect，与预期不符。
       * 【解决方式】：在run中执行fn之前，先清除 effect.deps 中所有dep对应的effect，然后执行fn，会重新进行依赖收集
       */
      cleanupEffect(this);
      return this.fn(); // 执行fn的时候就会取值，取值的时候收集当前的activeEffect
    } finally {
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
}

export function effect(fn) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();
}
```

### track
```js
// 双向依赖收集
const targetMap = new WeakMap();
export function track(target, key) {
  // 1. 如果取值操作没有发生在effect中，直接返回，不会进行依赖收集
  if (!activeEffect) {
    return;
  }
  // 2. 从映射表中读取属性对应的dep
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  let shouldTrack = !dep.has(activeEffect);
  // 3. 双向收集：一个属性可能对应多个effect，一个effect可能对应多个属性
  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
```

### trigger
```js   
export function trigger(target, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep = depsMap.get(key);
  if (dep) {
    const effects = [...dep];
    // 执行dep中所有effect的run方法
    effects.forEach((effect) => {
      /**
       * 【问题描述】如果在effect内部修改依赖，会触发effect重新执行，造成死循环；
       * effect(() => {
       *  state.age = Math.random();  // 在effect内部修改state，如果此时重新执行当前的activeEffect，会造成死循环
       *  app.innerHTML = state.age
       * })
       * 所以重新执行effect时需要判断重新执行的effect是否是当前的activeEffect，如果是当前的activeEffect，则不重新执行
       */
      if (activeEffect !== effect) {
        effect.run();
      }
    });
  }
}
```

### runner.effect.stop()
```js
export class ReactiveEffect {
  // ...
  stop() {
    // 先将effect的依赖全部删除掉，然后将它变成失活态
    if (this.active) {
      cleanupEffect(this);
      this.active = false;
    }
  }
}
export function effect(fn) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();

  const runner = _effect.run.bind(_effect); // 保证_effect执行的时候this是当前的effect
  runner.effect = _effect;
  return runner;
}
```

### computed
#### 拆分 track 和 trigger
```js
/**
 * 双向依赖收集
 */
const targetMap = new WeakMap();
export function track(target, key) {
  if (!activeEffect) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  trackEffects(dep);
}
export function trackEffects(dep) {
  let shouldTrack = !dep.has(activeEffect);
  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}

/**
 * 触发更新
 */
export function trigger(target, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep = depsMap.get(key);
  triggerEffects(dep);
}
export function triggerEffects(dep) {
  if (dep) {
  const effects = [...dep];
    effects.forEach((effect) => {
        if (activeEffect !== effect) {
            if (!effect.scheduler) {
                effect.run();
            } else {
                effect.scheduler();
            }
        }s
    });
  }
}
```
#### 实现computed
```js
import { isFunction } from "@vue/shared";
import {
  ReactiveEffect,
  activeEffect,
  trackEffects,
  triggerEffects,
} from "./effect";

const noop = () => {};
class ComputedRefImpl {
  dep = undefined;
  effect;
  __v_isRef = true;
  _dirty = true; // 是否需要重新计算
  _value; // 计算属性的缓存结果
  constructor(getter, public setter) {
    this.effect = new ReactiveEffect(getter, () => {
      // 属性更新时，触发trigger重新执行effect，但是不执行run，而是执行scheduler，将dirty设为true，下次取值时重新计算；
      // 2. 并且触发 this.dep 中所有effect（即计算属性作为依赖的effect）执行
      this._dirty = true;
      triggerEffects(this.dep);
    });
  }
  // get 和 set 是类的属性访问器，等价于 Object.defineProperty() 中的get、set
  get value() {
    if (activeEffect) {
      // 1. 读取计算属性时，如果存在activeEffect，意味着这个计算属性在effect中使用，需要让这个计算属性收集这个effect
      trackEffects(this.dep || (this.dep = new Set()));
    }

    if (this._dirty) {
      // 取值时才执行effect，并且把取到的值缓存起来
      this._value = this.effect.run(); // 执行计算属性的 getter，会进行依赖收集
      this._dirty = false;
    }
    return this._value;
  }
  set value(newValue) {
    this.setter(newValue);
  }
}

export function computed(getterOrOptions) {
  let onlyGetter = isFunction(getterOrOptions);
  let getter;
  let setter;
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = noop;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set || noop;
  }

  return new ComputedRefImpl(getter, setter);
}
```

### watch
```js
import { isReactive } from "./reactive";
import { ReactiveEffect } from "./effect";
import { isFunction, isObject } from "@vue/shared";

// 深度监听
function traverse(source, s = new Set()) {
  if (!isObject(source)) {
    return source;
  }
  if (s.has(source)) {
    return source;
  }
  s.add(source);
  for (let key in source) {
    // 递归取值，取值过程就是收集依赖的过程，即实现了深度监听
    traverse(source[key], s);
  }
  return source;
}
export function watch(source, cb, options) {
  let getter;
  // 【关键】watch第一个参数是对象时，该对象必须是响应式的
  if (isReactive(source)) {
    // watch第一个参数是响应式对象时，默认需要开启深度监听（通过traverse递归取值实现）
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  // watcher effect 的依赖变化时，就会执行scheduler（即job）
  const job = () => {
    // 在 scheduler 中调用 cb
    let newValue = effect.run(); // 再次执行effect.run()，即再次执行getter，拿到新值
    cb(newValue, oldValue);
    oldValue = newValue;
  };
  const effect = new ReactiveEffect(getter, job);
  // immediate为true会默认先执行一次回调
  if (options?.immediate) {
    return job();
  }
  oldValue = effect.run(); // 执行getter，收集依赖
}
```

### watchEffect
```js
function doWatch(source, cb, { immediate } = {} as any) {
  let getter;
  if (isReactive(source)) {
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  // watcher effect 的依赖变化时，就会执行scheduler（即job）
  const job = () => {
    // 2.1. 如果是watch API，在 scheduler 中调用 cb
    if (cb) {
      let newValue = effect.run();
      cb(newValue, oldValue);
      oldValue = newValue;
    } else {
      // 2.2. 如果是 watchEffect API，在 scheduler 中再次执行 effect.run
      effect.run();
    }
  };
  const effect = new ReactiveEffect(getter, job);
  if (immediate) {
    return job();
  }
  oldValue = effect.run(); // 1. 执行getter，收集依赖
}

/**
 * watch 和 watchEffect的区别：
 * 1. watch 就是一个 effect + 自定义scheduler（在scheduler中执行回调cb）
 * 2. watchEffect 就是一个 effect（只是在scheduler中执行 effect.run() 而已）
 */
export function watch(source, cb, options) {
  doWatch(source, cb, options);
}
export function watchEffect(effect, options) {
  doWatch(effect, null, options);
}
```
### watch 的 onCleanup
问题描述及解决方案：关键在于**闭包**，在下一次请求时将上一次的 flag 设为 false，导致上一次的请求结果无法渲染。
```html
<script type="module">
    import { reactive, effect, watch } from '../dist/reactivity.esm.js';
    const state = reactive({flag: false, name: 'sds', age: 28})
    /**
     *  【问题描述】：第一次接口请求速度慢，第二次重复请求该接口速度比较快，期望是以最新的请求结果为准，但是第一次请求的结果会覆盖掉第二次的请求结果，与预期不符
     **/
    let timer = 3000;
    function getData(data) {
        return new Promise((resolve,reject) => {
            setTimeout(() => {
                resolve(data)
            }, timer -= 1000)
        })
    }
    // 1. 手动解决方案
    // let arr = []
    // watch(() => state.name, async function(newValue) {
    //     // let r = await getData(newValue);
    //     // app.innerHTML = r; 
    //     let flag = true;
    //     while (arr.length) {
    //         let cb = arr.shift()
    //         cb()
    //     }
    //     arr.push(() => {    // 这个函数是个闭包
    //         flag = false;
    //     })
    //     let r = await getData(newValue);
    //     if(flag) {
    //         app.innerHTML = r
    //     }
    // })
    // 2. 使用 cleanup 解决
    watch(() => state.name, async function(newValue, oldValue, onCleanup) {
        let flag = true;
        // 这个函数是个【闭包】，会修改上一次的flag为false，导致上一次的结果不会执行下面的 app.innerHTML = r
        onCleanup(() => {    
            flag = false;
        })
        let r = await getData(newValue);
        if(flag) {
            app.innerHTML = r
        }
    })
    state.name = 1
    state.name = 2
</script>
```
onCleanup 的实现：
```js
function doWatch(source, cb, { immediate } = {} as any) {
  let getter;
  if (isReactive(source)) {
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  let cleanup;
  function onCleanup(userCb) {
    cleanup = userCb;
  }
  const job = () => {
    // 2.1. 如果是watch API，在 scheduler 中调用 cb
    if (cb) {
      let newValue = effect.run();
      // watch的回调函数入参中如果存在cleanup，优先执行cleanup
      if (cleanup) {
        cleanup();
      }
      cb(newValue, oldValue, onCleanup);
      oldValue = newValue;
    } else {
      // 2.2. 如果是 watchEffect API，在 scheduler 中再次执行 effect.run
      effect.run();
    }
  };
  const effect = new ReactiveEffect(getter, job);
  if (immediate) {
    return job();
  }
  oldValue = effect.run();
}
```

### ref
```js
import { isObject } from "@vue/shared";
import { reactive } from "./reactive";
import { activeEffect, trackEffects, triggerEffects } from "./effect";

export function ref(value) {
  return new RefImpl(value);
}

function toReactive(value) {
  return isObject(value) ? reactive(value) : value;
}
class RefImpl {
  dep = undefined;
  _value;
  __v_isRef = true;
  constructor(public rawValue) {
    // 如果 ref 传入的是对象，则用reactive将它变成响应式的
    this._value = toReactive(rawValue);
  }
  get value() {
    // 依赖收集
    if (activeEffect) {
      trackEffects(this.dep || (this.dep = new Set()));
    }
    return this._value;
  }
  set value(newValue) {
    if (newValue !== this.rawValue) {
      // 更新数据：newValue 也需要用 toReactive 进行处理
      this._value = toReactive(newValue);
      this.rawValue = newValue;
      // 触发effect更新
      triggerEffects(this.dep);
    }
  }
}
```

### toRef
`toRef` 本质上就是一个代理，以 `let name = toRef(person,'name')` 为例，它是通过 class 的 `get` 和 `set` 将 `name.value` 代理到 `person.name`；
```js
export function toRef(target, key) {
  return new ObjectRefImpl(target, key);
}
class ObjectRefImpl {
  __v_isRef = true;
  constructor(public _object, public _key) {}
  get value() {
    return this._object[this._key];
  }
  set value(newValue) {
    this._object[this._key] = newValue;
  }
}
```

### toRefs
`toRefs` 本质是遍历对象，对每一个属性使用 `toRef` 进行代理，使得解构之后的对象属性仍具有响应式。
```js
export function toRefs(object) {
  const ret = {};
  for (let key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
```

### proxyRefs
用户在模板中使用 `ref` 数据不用手动添加 `.value` 的原因就是内部会将数据用 `proxyRefs` 做处理。
`proxyRefs` 用 `Proxy` 代理一个对象
1. 如果对象属性是 Ref 类型，则将 `get` 和 `set` 都代理到该属性的 `.value` 属性上
2. 如果对象属性不是 Ref 类型，则正常取值和设值

```js
export function proxyRefs(objectWithRefs) {
  return new Proxy(objectWithRefs, {
    get(target, key, receiver) {
      let v = Reflect.get(target, key, receiver);
      return v.__v_isRef ? v.value : v;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      if (oldValue.__v_isRef) {
        oldValue.value = value;
        return true;
      }
      return Reflect.set(target, key, value, receiver);
    },
  });
}
```

### effectScope
effectScope 用于创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即**计算属性**和**侦听器**)，这样捕获到的副作用可以一起处理。
特征：
1. 通过 `effectScope()` 创建一个作用域
2. 通过 `scope.run()` 执行回调，并收集内部的 effect 副作用
3. scope 内部可以嵌套 scope
4. 通过 `scope.stop()` 可以执行所有收集的 `effect.stop()`，并执行内部嵌套的非独立scope的 `effect.stop()`

```js
// effectScope.ts
export let activeEffectScope;
class EffectScope {
  active = true;
  effects = []; // 用来收集scope内部的effects
  parent; // 通过 parent 处理 effectScope 嵌套的情况
  scopes; // 嵌套scope时，用来收集内层的scope
  constructor(detached = false) {
    // 收集内层非独立的 scope
    if (!detached && activeEffectScope) {
      (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this);
    }
  }
  run(fn) {
    if (this.active) {
      try {
        this.parent = activeEffectScope;
        // 执行run时，将当前的effectScope放到全局的activeEffectScope，方便在创建内部的effect时，取到effectScope，并收集内部的effect
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = this.parent;
        this.parent = null; // 垃圾回收
      }
    }
  }
  stop() {
    if (this.active) {
      this.effects.forEach((effect) => {
        effect.stop(); // 遍历 effectScope 收集的effects，执行它们的 stop 方法
      });
    }
    // 嵌套时，收集的内层 scope 也需要执行 stop
    if (this.scopes) {
      this.scopes.forEach((scope) => {
        scope.stop();
      });
    }
    this.active = false;
  }
}

// 在effectScope.effects中收集相关的effectScope.run 内部的 effect
export function recordEffectScope(effect) {
  if (activeEffectScope && activeEffectScope.active) {
    activeEffectScope.effects.push(effect);
  }
}

export function effectScope(detached) {
  return new EffectScope(detached);
}
```
创建 effect 时，执行 `recordEffectScope`，在 `activeEffectScope` 中收集相关的 `effect`：
```js
// effect.ts
export class ReactiveEffect {
    // ...
    constructor(public fn, public scheduler) {
        // 在 effectScope 内如果创建了 effect，会将该 effect 收集到 effectScope.effects 中
        recordEffectScope(this);
    }
    // ...
}
```

## runtime-dom
### 创建模块
在packages 目录下创建 `runtime-dom/package.json` 文件
```json
{
  "name": "@vue/runtime-dom",
  "version": "1.0.0",
  "main": "index.js",
  "module": "dist/runtime-dom.esm-bundler.js",
  "unpkg": "dist/runtime-dom.global.js",
  "buildOptions": {
    "name": "VueRuntimeDOM",
    "formats": [
      "esm-bundler",
      "cjs",
      "global"
    ]
  }
}
```
### 安装依赖
安装 `@vue/shared` 依赖：
```
pnpm install @vue/shared@workspace --filter @vue/runtime-dom
```
### 代码实现
创建目录文件：
```
│  │  └─ src
│  │     ├─ index.ts
│  │     ├─ modules
│  │     │  ├─ attr.ts  // attributes 的更新方法
│  │     │  ├─ class.ts // class 的更新
│  │     │  ├─ event.ts // 事件绑定的更新
│  │     │  └─ style.ts // style属性的更新
│  │     ├─ nodeOps.ts  // dom操作方法
│  │     └─ patchProp.ts    // 属性更新操作
```
```js
// nodeOps.ts
/**
 * 元素、文本的增删改查
 */
export const nodeOps = {
  // 1. 创建元素
  createElement(tagName) {
    return document.createElement(tagName);
  },
  // 2. 插入元素
  insert(child, parent, anchor) {
    // 元素移动；
    // 当第二个参数为null时，插入到末尾；
    parent.insertBefore(child, anchor || null);
  },
  // 3. 移除元素
  remove(child) {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  // 4. 查询元素
  querySelector(selector) {
    return document.querySelector(selector);
  },
  parentNode(node) {
    return node.parentNode;
  },
  nextSibling(node) {
    return node.nextSibling;
  },
  // 创建文本节点
  createText(text) {
    return document.createTextNode(text);
  },
  // 5. 设置文本
  setElementText(el, text) {
    el.textContent = text;
  },
  setText(node, text) {
    node.nodeValue = text;
  },
};
```
```js
// patchProp.ts
import { patchAttr } from "./modules/attr";
import { patchClass } from "./modules/class";
import { patchEvent } from "./modules/event";
import { patchStyle } from "./modules/style";

export const patchProp = (el, key, prevValue, nextValue) => {
  if (key === "class") {
    // 1. class 类名
    patchClass(el, nextValue);
  } else if (key === "style") {
    // 2. 样式
    patchStyle(el, prevValue, nextValue);
  } else if (/^on[^a-z]/.test(key)) {
    // 3. onXxx 事件
    patchEvent(el, key, nextValue);
  } else {
    // 4. 其它 attributes 属性
    patchAttr(el, key, nextValue);
  }
};
```
```js
// modules/attr.ts
export const patchAttr = (el, key, value) => {
  if (value == null) {
    el.removeAttribute(key);
  } else {
    el.setAttribute(key, value);
  }
};
```
```js
// modules/class.ts
export const patchClass = (el, value) => {
  if (value == null) {
    el.removeAttribute("class");
  } else {
    el.className = value;
  }
};
```
```js
// modules/style.ts
export const patchStyle = (el, prev, next) => {
  const style = el.style;
  // 1. 将新的样式添加到style上，如果有重复的直接覆盖
  for (let key in next) {
    style[key] = next[key];
  }
  for (let key in prev) {
    // 2. 老的有，新的没有，要移除掉
    if (next[key] == null) {
      style[key] = null;
    }
  }
};
```
```js
// modules/event.ts
function createInvoker(initialValue) {
  const invoker = (e) => invoker.value(e);
  // 将事件的回调绑定到 invoker.value 上，后续更新事件回调的时候，只需更新 invoker.value 即可
  invoker.value = initialValue;
  return invoker;
}

export const patchEvent = (el, key, nextValue) => {
  const invokers = el._vei || (el._vei = {}); // _vei 是 vue event invoker 的缩写
  const name = key.slice(2).toLowerCase(); // 事件名
  const existingInvoker = invokers[name]; // 取缓存

  // 1. 如果是更新事件的回调
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    // 2. 如果是绑定新的事件
    if (nextValue) {
      // 创建 invoker 并缓存起来
      const invoker = (invokers[name] = createInvoker(nextValue));
      el.addEventListener(name, invoker);
    } else {
      // 3. 如果是移除事件
      el.removeEventListener(name, existingInvoker);
      invokers[name] = null;
    }
  }
};
```

## runtime-core
### 创建模块
在packages 目录下创建 `runtime-core/package.json` 文件
```json
{
  "name": "@vue/runtime-core",
  "version": "1.0.0",
  "module": "dist/runtime-core.esm-bundler.js",
  "types": "dist/runtime-core.d.ts",
  "files": [
    "index.js",
    "dist"
  ],
  "buildOptions": {
    "name": "VueRuntimeCore",
    "formats": [
      "esm-bundler",
      "cjs"
    ]
  },
  "dependencies": {
    "@vue/shared": "workspace:^1.0.0"
  }
}
```
### 安装依赖
安装 `@vue/shared` 依赖：
```
pnpm install @vue/shared@workspace --filter @vue/runtime-core
```
### 代码实现
#### h 函数
h 函数就是通过区分不同的传参情况，调用createVNode创建虚拟节点
```js
import { isArray, isObject } from "@vue/shared";
import { isVNode, createVNode } from "./vnode";

export function h(type, propsOrChildren?, children?) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      // 1. h(type, h(...))
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      // 2. h(type, props)
      return createVNode(type, propsOrChildren);
    } else {
      // 3. h(type, [...children]) 或 h(type, '文本')
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    // l = 1 或 l >= 3
    if (l > 3) {
      // 4. h(type, {}, child1, child2, child3)
      children = Array.from(arguments).slice(2);
    } else if (l === 3 && isVNode(children)) {
      // 5. h(type, props, h(...))
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
```

#### ShapeFlags
ShapeFlags 通过位运算记录不同的vnode类型和children类型;
位运算符针对于二进制数：
  1. 左移运算符 <<
    + FUNCTIONAL_COMPONENT = 1 << 1  即 00000001 往前移一位，变成 00000010，即十进制的 2
    + STATEFUL_COMPONENT = 1 << 2  即 00000001 往前移两位，变成 00000100，即十进制的 4
  2. 或运算 |：两个位都为0时，结果才为0；有一个为1，结果就为1
    + COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT，即 00000010 | 00000100， | 运算符的规则是对应的位上有一个位1即为1，则合并进行位运算结果为 00000110，即十进制的 6
  3. 与运算 &：两个位都为1时，结果才为1
    + 判断一个Vnode是否是函数式组件：ShapeFlags.COMPONENT & ShapeFlags.FUNCTIONAL_COMPONENT，即 00000110 & 00000100，对应位上进行与操作，两者都为1结果才为1，则结果为00000100，大于0，说明该vnode是函数式组件
    + 在实际判断 vnode.shapeFlag 是什么类型时，就用 vnode.shapeFlag & ShapeFlags.xxx，结果大于1 则说明该vnode包含该类型。

```js
export const enum ShapeFlags {
  ELEMENT = 1, // 虚拟节点是一个元素
  FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件
  STATEFUL_COMPONENT = 1 << 2, // 状态组件，即普通组件
  TEXT_CHILDREN = 1 << 3, // 儿子是文本
  ARRAY_CHILDREN = 1 << 4, // 儿子是数组
  SLOTS_CHILDREN = 1 << 5, // 插槽
  TELEPORT = 1 << 6, // teleport
  SUSPENSE = 1 << 7, // suspense
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8, // 是否需要keep-alive
  COMPONENT_KEPT_ALIVE = 1 << 9, // 组件是否经过keep-alive
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT, // 函数式组件或普通组件
}
```

#### createVNode
```js
import { isArray, isString, ShapeFlags } from "@vue/shared";

export function isVNode(vnode) {
  return vnode.__v_isVnode == true;
}
export function isSameVNode(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
export function createVNode(type, props = null, children = null) {
  // 用标识区分不同的虚拟节点类型（组件、元素、文本、自定义的 keep-alive/Teleport等）
  const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0; // 即 0001 或 0000
  const vnode = {
    __v_isVnode: true,
    type,
    props,
    children,
    shapeFlag,
    key: props?.key,
    else: null, // 对应的真实节点
  };
  if (children) {
    let childrenType = 0;
    if (isArray(children)) {
      childrenType = ShapeFlags.ARRAY_CHILDREN; // 1 << 4
    } else {
      childrenType = ShapeFlags.TEXT_CHILDREN; // 1 << 3
    }
    // vnode.shapeFlag 除了记录vnode本身的类型，还需要记录children的类型是数组还是文本（| 操作符会在二进制对应的位上进行相加运算，相当于记录了children的类型）
    vnode.shapeFlag = vnode.shapeFlag | childrenType;
  }
  return vnode;
}
```

#### runtime-dom 里的render
runtime-dom 导出的 render 的本质还是调用 createRenderer，并传入runtime-dom中的renderOptions
```js
import { createRenderer } from "@vue/runtime-core";
export const render = (vnode, container) => {
  return createRenderer(renderOptions).render(vnode, container);
};
```
#### createRenderer
```js
import { ShapeFlags } from "@vue/shared";
import { isSameVNode } from "./vnode";

export function createRenderer(options) {
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
  } = options;

  // 渲染children，本质是递归调用patch
  const mountChildren = (children, el) => {
    for (let i = 0; i < children.length; i++) {
      patch(null, children[i], el);
    }
  };
  // 卸载children
  const unmountChildren = (children) => {
    for (let i = 0; i < children.length; i++) {
      unmount(children[i]);
    }
  };

  // 创建元素dom
  const mountElement = (vnode, container) => {
    const { type, props, children, shapeFlag } = vnode;
    // 1. 创建真实dom，并保存到 vnode.el 上
    const el = (vnode.el = hostCreateElement(type));
    // 2. 增添属性
    if (props) {
      for (let key in props) {
        hostPatchProp(el, key, null, props[key]);
      }
    }
    // 3. 渲染children：children 可能是文本或数组
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      mountChildren(children, el);
    } else if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      hostSetElementText(el, children);
    }
    // 4. 插入到页面
    hostInsert(el, container);
  };

  // 更新props
  const pacthProps = (oldProps, newProps, el) => {
    if (oldProps !== newProps) {
      // 新的与老的不同，用新的覆盖老的
      for (let key in newProps) {
        const prev = oldProps[key];
        const next = newProps[key];
        if (prev !== next) {
          hostPatchProp(el, key, prev, next);
        }
      }
      // 老的存在，新的没有，则删掉老的
      for (let key in oldProps) {
        const prev = oldProps[key];
        if (!(key in newProps)) {
          hostPatchProp(el, key, prev, null);
        }
      }
    }
  };

  // Diff 算法
  const patchKeyedChildren = (c1, c2, el) => {
    // TODO...
  };

  // 更新 children
  const patchChildren = (n1, n2, el) => {
    // 比较两个vnode的children，更新el中的children
    const c1 = n1.children;
    const c2 = n2.children;
    const prevShapeFlag = n1.shapeFlag;
    const shapeFlag = n2.shapeFlag;
    // 1. c2 是文本
    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      // 如果 c1 是数组
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // 把老的children删除
        unmountChildren(c1);
      }
      // 设置新的文本内容
      if (c1 !== c2) {
        hostSetElementText(el, c2);
      }
    } else {
      // 2. c2 是数组或 null
      // 2.1 c1 是数组
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          // 2.1.1  c1、c2 都是数组
          // 【diff 算法】
          patchKeyedChildren(c1, c2, el);
        } else {
          // 2.1.2  c1 是数组，c2 是 null，删除老的children
          unmountChildren(c1);
        }
      } else {
        // 2.2 c1 文本或null
        // 2.2.1  c1 是文本（c2是数组或null），则直接删除文本，删除后c1变成了null
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
          hostSetElementText(el, "");
        }
        // 2.2.2  当 c1 是 null，c2是children时，渲染c2（c2是null，c1也是null时，不做处理）
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          mountChildren(c2, el);
        }
      }
    }
  };

  const patchElement = (n1, n2) => {
    let el = (n2.el = n1.el);
    const oldProps = n1.props || {};
    const newProps = n2.props || {};
    // 更新props
    pacthProps(oldProps, newProps, el);
    // 更新 children
    patchChildren(n1, n2, el);
  };
  const processElement = (n1, n2, container) => {
    if (n1 == null) {
      // 初次渲染
      mountElement(n2, container);
    } else {
      // diff 算法
      patchElement(n1, n2);
    }
  };

  // 初次渲染或更新vnode
  const patch = (n1, n2, container) => {
    if (n1 == n2) {
      return;
    }
    // 如果n1、n2都有值，但不是sameVNode，则删除n1，渲染n2
    if (n1 && !isSameVNode(n1, n2)) {
      unmount(n1);
      n1 = null; // 在 processElement 中会判定，当n1为null时，直接渲染n2
    }
    processElement(n1, n2, container);
  };

  // 卸载vnode
  const unmount = (vnode) => hostRemove(vnode.el);

  const render = (vnode, container) => {
    if (vnode == null) {
      // 卸载：删除节点
      // container._vnode上是container内渲染过的vnode，只有当container渲染过了才进行卸载
      if (container._vnode) {
        unmount(container._vnode);
      }
    } else {
      // 初次渲染 或 更新
      patch(container._vnode || null, vnode, container);
    }
    // 将虚拟节点保存到真实节点的 _vnode 属性上
    container._vnode = vnode;
  };
  return {
    render,
  };
}
```

## Diff 算法
当两个vnode的children都是数组时，进行diff比较：
1. 从前往后比
2. 从后往前比
3. 在老的 children 后面或前面插入新值
4. 从老的 children 前面或后面删去一部分节点
5. 乱序比较
   1. 老的里面有，新的没有，则删除老节点
   2. 老的和新的里面都有，则比对两个节点，尽可能复用老节点
   3. 上述两种情况只是对相同的vnode进行了更新，并没有移动老节点的顺序，也没有在 newChildren 里面添加新增的节点
      1. 创建新节点；调整节点顺序
      2. 利用 最长递增子序列 优化排序（对于顺序不变的子序列，不移动位置）

```js
  const patchKeyedChildren = (c1, c2, el) => {
    // TODO...  block tree、patchFlags

    // 同级比较 + 深度遍历
    let i = 0;
    let e1 = c1.length - 1; // prevChildren ending index
    let e2 = c2.length - 1; // nextChildren ending index

    /**
     * 1. 从前往后比
     * (a b) c    ——>
     * (a b) d e
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i];
      if (isSameVNode(n1, n2)) {
        // 递归执行 patch
        patch(n1, n2, el);
      } else {
        break; // break 用于完全结束循环体，跳出循环
      }
      i++;
    }

    /**
     * 2. 从后往前比
     * a (b c)    ——>
     * d e (b c)
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2];
      if (isSameVNode(n1, n2)) {
        patch(n1, n2, el);
      } else {
        break;
      }
      e1--;
      e2--;
    }

    /**
     * 3. 在老的 children 后面或前面插入新值
     * (a b) ——> (a b) c，此时 i = 2, e1 = 1, e2 = 2
     * (a b) ——> c (a b)，此时 i = 0, e1 = -1, e2 = 0
     * 即当 i > e1时，说明老的比新的短（e1 < e2），有新增
     */
    if (i > e1) {
      // i一定是要小于e2的
      if (i <= e2) {
        // 循环创建新元素
        while (i <= e2) {
          // 如果e2往前移动了，那么e2的下一个值一定存在，说明向前插入
          const nextPos = e2 + 1;
          // anchor 即插入元素时的锚点，为null时直接插入到末尾
          // vue2 是看下一个元素存不存在，vue3是看下一个元素的长度是否越界
          const anchor = nextPos < c2.length ? c2[nextPos].el : null;
          patch(null, c2[i], el, anchor);
          i++;
        }
      }
    } else if (i > e2) {
      /**
       * 4. 从老的 children 前面或后面删去一部分节点
       * (a b) c ——> (a b)，此时 i = 2, e1 = 2, e2 = 1
       * a (b c) ——> (b c)，此时 i = 0, e1 = 0, e2 = -1
       * 即当 i > e2时，说明老的比新的长（e1 > e2），有删减
       */
      while (i <= e1) {
        unmount(c1[i]);
        i++;
      }
    } else {
      /**
       * 5. 乱序比较
       * a b [c d e] f g ——>  a b [e c d h] f g，此时 i = 2, e1 = 4, e2 = 5
       */
      let s1 = i; // prevChildren starting index
      let s2 = i; // nextChildren starting index
      // vue2中根据老节点创建映射表，vue3中根据新的key创建映射表
      const keyToNewIndexMap = new Map();
      // 遍历 s2-e2 片段，创建映射表，存储newChildren中的索引
      for (i = s2; i <= e2; i++) {
        const vnode = c2[i];
        keyToNewIndexMap.set(vnode.key, i);
      }

      const toBePatched = e2 - s2 + 1;
      // 创建一个数组，用来标记 s2-e2 片段节点是否被patch过，初始值为0，patch过则设为 oldIndex + 1
      const newIndexToOldIndex = new Array(toBePatched).fill(0); // [0,0,0,0]
      // 遍历 s1-e1 片段，查找老节点是否存在于 newChildren 中，然后进行卸载或递归patch
      for (i = s1; i <= e1; i++) {
        const child = c1[i];
        // 通过key查找老节点在newChildren中对应的索引
        let newIndex = keyToNewIndexMap.get(child.key);
        // 5.1.1 老的里面有，新的没有，则删除老节点
        if (newIndex == undefined) {
          unmount(child);
        } else {
          // 5.1.2 老的和新的里面都有，则比对两个节点，尽可能复用老节点
          // patch过的节点，在 newIndexToOldIndex 中记录为 oldIndex + 1（加1是为了避免oldIndex为0时，与初始值0冲突，造成语义不清）
          newIndexToOldIndex[newIndex - s2] = i + 1;
          patch(child, c2[newIndex], el); // patch 更新节点
          // 截至目前，只是对相同的vnode进行了更新，并没有移动老节点的顺序，也没有在 newChildren里面添加新增的节点
        }
      }
      // console.log(newIndexToOldIndex); // [5,3,4,0]
      // 5.2 创建新节点；调整节点顺序
      for (let i = toBePatched - 1; i >= 0; i--) {
        // a b [e c d h] f g
        const nextIndex = s2 + i; // 获取节点的索引
        const nextChild = c2[nextIndex]; // 获取节点vnode
        const anchor = nextIndex + 1 < c2.length ? c2[nextIndex + 1].el : null; // 获取锚点
        if (newIndexToOldIndex[i] == 0) {
          // 如果是新元素则创建元素，再插入
          patch(null, nextChild, el, anchor);
        } else {
          // 如果不是新元素，直接插入节点（倒序插入）
          hostInsert(nextChild.el, el, anchor); // insert 是移动节点
          // 这个插入操作有点暴力，每个节点都移动了一次，需要进行优化
          // 新老children中顺序不变的节点不必移动
          // TODO...【最长递增子序列】
        }
      }
    }
  };
```