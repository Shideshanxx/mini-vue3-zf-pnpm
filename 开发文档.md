## Vue3 与 Vue2 的区别介绍
Vue3新增设计：
+ **模块拆分**：Vue3 源码采用 menorepo 方式进行管理，将模块拆分到 packages 中
+ Vue3 采用 **TS** 开发，增强类型检测。Vue2 采用 flow
+ Vue3 的性能优化，支持 **Tree-Shaking** ，不使用就不会打包
+ 允许**自定义渲染器**，扩展能力强。
+ Vue3 后期引入 **RFC**（Request For Comments 意即“请求评论”），使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)，记录了很多基于讨论实现的功能

Vue3 内部代码优化：
+ Vue2 采用 `defineProperty` 进行对象的数据劫持，有性能问题和缺陷；**Vue3 采用 `Proxy` 进行数据劫持**。
+ **Vue3 中对模板编译进行了优化**，编译时生成了 Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点
+ **Vue3 采用 composition API 进行组织功能**，解决反复横跳，优化逻辑复用（优化 `mixin` 带来的数据来源不清晰、命名冲突等），相比 options API 类型推断更加方便
+ **Vue3 增加了 `Fragment`、`Teleport`、`Suspense` 组件**

## Vue3 架构分析
### 1. Monorepo 介绍
`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库（repo）中管理多个包/模块（packages）。
+ 一个仓库可以维护多个模块，不用到处找仓库
+ 方便版本管理和依赖管理，模块之间的引用，调用都非常方便

> 缺点：仓库体积会变大

### 2. Vue3 项目结构
在 [vue3源码](https://github.com/vuejs/core/tree/main) 中可以看到，`packages`中一共有十几个模块：
+ `reactivity`：响应式系统
+ `runtime-core`：与平台无关的运行时核心（可以创建针对特定平台的运行时 - 自定义渲染器）
+ `runtime-dom`：针对浏览器的运行时（包括 DOM API、属性、事件等）
+ `runtime-test`：用于测试的运行时
+ `server-renderer`：用于服务端渲染
+ `compiler-core`：与平台无关的编译器核心
+ `compiler-dom`：针对浏览器的编译模块
+ `compiler-ssr`：针对服务端渲染的编译模块
+ `compiler-sfc`：针对单文件解析
+ `size-check`：用来测试代码体积
+ `template-explorer`：用于调试编译器输出的开发工具
+ `shared`：多个包之间共享的内容
+ `vue`：完整版本，包括浏览器的运行时和编译器
+ ...

`vue` 包的核心模块如下：
```
                          +-------------------+
                          |                   |
                          | @vue/compiler-sfc |
                          |                   |
                          +-----+--------+----+
                                |        |
                                v        v
              +-------------------+    +--------------------+
              |                   |    |                    |
     +------->| @vue/compiler-dom +--->| @vue/compiler-core |
     |        |                   |    |                    |
+----+----+   +-------------------+    +--------------------+
|         |
|   vue   |
|         |
+----+----+   +------------------+    +-------------------+    +-----------------+
     |        |                  |    |                   |    |                 |
     +------->| @vue/runtime-dom +--->| @vue/runtime-core +--->| @vue/reactivity |
              |                  |    |                   |    |                 |
              +------------------+    +-------------------+    +-----------------+
```

## 搭建开发环境
1. 创建文件夹 `mini-vue3-zf-pnpm`，并初始化项目
    ```
    pnpm init
    ```
2. 创建 `packages/reactivity/src/index.ts`、`packages/shared/src/index.ts` 两个文件夹
3. 创建 `.npmrc` 配置文件
    ```shell
    # pnpm安装vue时，默认不会将vue依赖的包展平到 node_modules 下，导致项目中无法使用vue的依赖
    # 通过以下配置将 vue 依赖的包展平到 node_modules 下
    shamefully-hoist = true
    ```
4. 创建 `pnpm-workspace.yaml`，定义工作空间的根目录
   ```yaml
   packages:
    - "packages/*"
   ```
5. 安装 `esbuild`、`typescript`、`minimist`（` minimist` 是一个专门用于处理Node.js启动参数的库）
   ```
   pnpm install esbuild typescript minimist -D -w
   ```
6. 初始化 typescript 配置文件
   ```
   pnpm tsc --init
   ```
   ```json
    {
        "compilerOptions": {
            "outDir": "dist", // 输出的目录
            "sourceMap": true,  // 采用 sourcemap
            "target": "es2016", // 目标语法
            "module": "esnext", // 模块格式
            "moduleResolution": "node", // 解析模块的方式
            "strict": false,  // 严格模式
            "resolveJsonModule": true,  // 解析json模块
            "esModuleInterop": true,  // 允许通过es6语法引入 commonjs 模块
            "jsx": "preserve",  // jsx 不转义
            "lib": ["esnext", "dom"]  // 支持的类库：esnext和dom
        }
    }
   ```
7. 进入 reactivity 模块，初始化子项目
   ```
   cd packages
   cd reactivity
   pnpm init
   ```
   修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/reactivity",
        "version": "1.0.0",
        "description": "",
        "module": "dist/reactivity.esm-bundler.js",
        "unpkg": "dist/reactivity.global.js",
        "buildOptions": {
            "name": "VueReactivity",
            "formats": [
                "esm-browser",
                "esm-bundler",
                "cjs",
                "global"
            ]
        }
    }
   ```
   > formats 为自定义的需要打包的格式：
   > + `global`：立即执行函数的格式，会暴露全局对象
   > + `esm-browser`：在浏览器中使用的格式，内联所有的依赖项
   > + `esm-bundler`：在构建工具中使用的格式，不提供 `.prod` 格式，在构建应用程序时会被构建工具一起进行打包压缩
   > + `cjs`：在node中使用的格式，例如服务端渲染
8. 同理，也进入 shared 模块，修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/shared",
        "version": "1.0.0",
        "module": "dist/shared.esm-bundler.js",
        "buildOptions": {
            "formats": [
                "esm-bundler",
                "cjs"
            ]
        }
    }
   ```
9. 在 `reactivity` 模块安装 `shared` 模块的依赖：
    ```
    pnpm install @vue/shared@workspace --filter @vue/reactivity
    ```
10. 在 `tsconfig.json` 中配置路径别名：
    ```json
    "baseUrl": ".",
    "paths": {
      "@vue/*": ["packages/*/src"]
    }
    ```
11. 对模块进行打包
    + 在根`package.json`中添加命令：`"dev": "node scripts/dev.js reactivity -f esm"`
    + 创建 `scripts/dev.js`：
        ```js
        const { build } = require("esbuild");
        const path = require("path");
        const args = require("minimist")(process.argv.slice(2)); // { _: [ 'reactivity' ], f: 'esm' }

        // 打包的模块是哪个
        const target = args._[0] || "reactivity";
        // 打包的格式是什么
        const format = args.f || "global";
        // 读取模块的 package.json 文件
        const pkg = require(path.resolve(
            __dirname,
            `../packages/${target}/package.json`
        ));
        // 输出格式：把 global 改成 iife
        const outputFormat = format.startsWith("global")
            ? "iife"
            : format === "cjs"
            ? "cjs"
            : "esm";
        // 输出的路径
        const outfile = path.resolve(
            __dirname,
            `../packages/${target}/dist/${target}.${format}.js`
        );

        // 使用esbuild打包
        build({
            entryPoints: [path.resolve(__dirname, `../packages/${target}/src/index.ts`)], // 入口
            outfile, // 出口
            bundle: true, // 是否打包到一起
            sourcemap: true, // 是否生成sourcemap文件（.map 结尾）
            format: outputFormat, // 打包的格式
            globalName: pkg.buildOptions?.name, // 打包的全局名称
            platform: format === "cjs" ? "node" : "browser", // 平台
            watch: {
                // 监控文件变化
                onRebuild(error) {
                if (!error) {
                    console.log("rebuild~~~");
                }
                },
            },
        }).then(() => {
            console.log("watching~~~");
        });
        ```

## 响应式
### reactive
```js
// reactive.ts
import { isObject } from "@vue/shared";
import { mutableHandlers } from "./baseHandlers";
export const enum ReactiveFlags {
    IS_REACTIVE = "__v_isReactive",
}
const reactiveMap = new WeakMap(); // 使用 WeakMap 防止内存泄漏
export function reactive(target) {
    // 1. reactive 只代理对象
    if (!isObject(target)) {
        return target;
    }
    // 2. 如果已经被代理过，则直接返回
    // 取 target[ReactiveFlags.IS_REACTIVE] 时，如果target已经被代理过，则会走到get函数，返回true
    if (target[ReactiveFlags.IS_REACTIVE]) {
        return target;
    }
    // 3. 不重复代理同一对象
    const existProxy = reactiveMap.get(target);
    if (existProxy) {
        return existProxy;
    }
    // 4. 创建代理
    const proxy = new Proxy(target, mutableHandlers);
    reactiveMap.set(target, proxy); // target -> proxy 的映射表
    return proxy;
}
```
```js
// baseHandlers.ts
import { ReactiveFlags } from "./reactive";
export const mutableHandlers = {
    // receiver 是当前的代理对象
    get(target, key, receiver) {
        // 通过下列判断，解决不重复代理已经经过代理的对象
        if (ReactiveFlags.IS_REACTIVE === key) {
            return true;
        }
        /**
        * 【问题描述】为何不能直接通过 target[key] 取值？
        * 现有一个对象person：
        * let person = {
        *    name: 'jw',
        *    get aliasName() {
        *        return 'alias' + this.name
        *    }
        * }
        * 当通过 person.aliasName 取值时，内部的 this.name （this指向person）是通过 person.name 读取的，不会触发响应式；
        * 而改成 Reflect.get(target, key, receiver) 后，this 指向 receiver，this.name 即 personProxy.name，依然会触发响应式；
        */
        track(target, key);
        return Reflect.get(target, key, receiver); // 【使用 Reflect.get 处理了 target 内部的 this 指向问题】
    },
    set(target, key, value, receiver) {
        let oldValue = target[key];
        const r = Reflect.set(target, key, value, receiver); // Reflect.set 返回一个boolean值
        if (oldValue !== value) {
            trigger(target, key, value, oldValue);
        }
        return r;
    },
};
```

### effect && cleanupEffect
```js
function cleanupEffect(effect) {
  // 每次执行effect之前，都应该将该effect从deps所有属性的dep中清理出去，以及清空effect的deps数组
  let { deps } = effect;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
export let activeEffect;
export class ReactiveEffect {
  public fn;
  public active = true;
  public deps = [];
  public parent = undefined;
  constructor(fn) {
    this.fn = fn;
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    // 通过设置parent属性，确保在嵌套effect中activeEffect的准确性
    try {
      this.parent = activeEffect;
      activeEffect = this;
      /**
       * 【意料之外的重新渲染】：每次触发 trigger 重新执行effect.run()，此时effect的依赖项可能发生变化（可能会删除之前的依赖或新增新的依赖），如果之前的依赖被删掉了，那么就需要清除之前收集的依赖，不然当该依赖变化时会重新执行effect，与预期不符。
       * 【解决方式】：在run中执行fn之前，先清除 effect.deps 中所有dep对应的effect，然后执行fn，会重新进行依赖收集
       */
      cleanupEffect(this);
      return this.fn(); // 执行fn的时候就会取值，取值的时候收集当前的activeEffect
    } finally {
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
}

export function effect(fn) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();
}
```

### track
```js
// 双向依赖收集
const targetMap = new WeakMap();
export function track(target, key) {
  // 1. 如果取值操作没有发生在effect中，直接返回，不会进行依赖收集
  if (!activeEffect) {
    return;
  }
  // 2. 从映射表中读取属性对应的dep
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  let shouldTrack = !dep.has(activeEffect);
  // 3. 双向收集：一个属性可能对应多个effect，一个effect可能对应多个属性
  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
```

### trigger
```js   
export function trigger(target, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep = depsMap.get(key);
  if (dep) {
    const effects = [...dep];
    // 执行dep中所有effect的run方法
    effects.forEach((effect) => {
      /**
       * 【问题描述】如果在effect内部修改依赖，会触发effect重新执行，造成死循环；
       * effect(() => {
       *  state.age = Math.random();  // 在effect内部修改state，如果此时重新执行当前的activeEffect，会造成死循环
       *  app.innerHTML = state.age
       * })
       * 所以重新执行effect时需要判断重新执行的effect是否是当前的activeEffect，如果是当前的activeEffect，则不重新执行
       */
      if (activeEffect !== effect) {
        effect.run();
      }
    });
  }
}
```

### runner.effect.stop()
```js
export class ReactiveEffect {
  // ...
  stop() {
    // 先将effect的依赖全部删除掉，然后将它变成失活态
    if (this.active) {
      cleanupEffect(this);
      this.active = false;
    }
  }
}
export function effect(fn) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();

  const runner = _effect.run.bind(_effect); // 保证_effect执行的时候this是当前的effect
  runner.effect = _effect;
  return runner;
}
```

## computed
### 拆分 track 和 trigger
```js
/**
 * 双向依赖收集
 */
const targetMap = new WeakMap();
export function track(target, key) {
  if (!activeEffect) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  trackEffects(dep);
}
export function trackEffects(dep) {
  let shouldTrack = !dep.has(activeEffect);
  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}

/**
 * 触发更新
 */
export function trigger(target, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep = depsMap.get(key);
  triggerEffects(dep);
}
export function triggerEffects(dep) {
  if (dep) {
  const effects = [...dep];
    effects.forEach((effect) => {
        if (activeEffect !== effect) {
            if (!effect.scheduler) {
                effect.run();
            } else {
                effect.scheduler();
            }
        }s
    });
  }
}
```
### 实现computed
```js
import { isFunction } from "@vue/shared";
import {
  ReactiveEffect,
  activeEffect,
  trackEffects,
  triggerEffects,
} from "./effect";

const noop = () => {};
class ComputedRefImpl {
  dep = undefined;
  effect;
  __v_isRef = true;
  _dirty = true; // 是否需要重新计算
  _value; // 计算属性的缓存结果
  constructor(getter, public setter) {
    this.effect = new ReactiveEffect(getter, () => {
      // 属性更新时，触发trigger重新执行effect，但是不执行run，而是执行scheduler，将dirty设为true，下次取值时重新计算；
      // 2. 并且触发 this.dep 中所有effect（即计算属性作为依赖的effect）执行
      this._dirty = true;
      triggerEffects(this.dep);
    });
  }
  // get 和 set 是类的属性访问器，等价于 Object.defineProperty() 中的get、set
  get value() {
    if (activeEffect) {
      // 1. 读取计算属性时，如果存在activeEffect，意味着这个计算属性在effect中使用，需要让这个计算属性收集这个effect
      trackEffects(this.dep || (this.dep = new Set()));
    }

    if (this._dirty) {
      // 取值时才执行effect，并且把取到的值缓存起来
      this._value = this.effect.run(); // 执行计算属性的 getter，会进行依赖收集
      this._dirty = false;
    }
    return this._value;
  }
  set value(newValue) {
    this.setter(newValue);
  }
}

export function computed(getterOrOptions) {
  let onlyGetter = isFunction(getterOrOptions);
  let getter;
  let setter;
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = noop;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set || noop;
  }

  return new ComputedRefImpl(getter, setter);
}
```

## watch && watchEffect && onCleanup
### watch
```js
import { isReactive } from "./reactive";
import { ReactiveEffect } from "./effect";
import { isFunction, isObject } from "@vue/shared";

// 深度监听
function traverse(source, s = new Set()) {
  if (!isObject(source)) {
    return source;
  }
  if (s.has(source)) {
    return source;
  }
  s.add(source);
  for (let key in source) {
    // 递归取值，取值过程就是收集依赖的过程，即实现了深度监听
    traverse(source[key], s);
  }
  return source;
}
export function watch(source, cb, options) {
  let getter;
  // 【关键】watch第一个参数是对象时，该对象必须是响应式的
  if (isReactive(source)) {
    // watch第一个参数是响应式对象时，默认需要开启深度监听（通过traverse递归取值实现）
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  // watcher effect 的依赖变化时，就会执行scheduler（即job）
  const job = () => {
    // 在 scheduler 中调用 cb
    let newValue = effect.run(); // 再次执行effect.run()，即再次执行getter，拿到新值
    cb(newValue, oldValue);
    oldValue = newValue;
  };
  const effect = new ReactiveEffect(getter, job);
  // immediate为true会默认先执行一次回调
  if (options?.immediate) {
    return job();
  }
  oldValue = effect.run(); // 执行getter，收集依赖
}
```

### watchEffect
```js
function doWatch(source, cb, { immediate } = {} as any) {
  let getter;
  if (isReactive(source)) {
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  // watcher effect 的依赖变化时，就会执行scheduler（即job）
  const job = () => {
    // 2.1. 如果是watch API，在 scheduler 中调用 cb
    if (cb) {
      let newValue = effect.run();
      cb(newValue, oldValue);
      oldValue = newValue;
    } else {
      // 2.2. 如果是 watchEffect API，在 scheduler 中再次执行 effect.run
      effect.run();
    }
  };
  const effect = new ReactiveEffect(getter, job);
  if (immediate) {
    return job();
  }
  oldValue = effect.run(); // 1. 执行getter，收集依赖
}

/**
 * watch 和 watchEffect的区别：
 * 1. watch 就是一个 effect + 自定义scheduler（在scheduler中执行回调cb）
 * 2. watchEffect 就是一个 effect（只是在scheduler中执行 effect.run() 而已）
 */
export function watch(source, cb, options) {
  doWatch(source, cb, options);
}
export function watchEffect(effect, options) {
  doWatch(effect, null, options);
}
```
### onCleanup
问题描述及解决方案：关键在于**闭包**，在下一次请求时将上一次的 flag 设为 false，导致上一次的请求结果无法渲染。
```html
<script type="module">
    import { reactive, effect, watch } from '../dist/reactivity.esm.js';
    const state = reactive({flag: false, name: 'sds', age: 28})
    /**
     *  【问题描述】：第一次接口请求速度慢，第二次重复请求该接口速度比较快，期望是以最新的请求结果为准，但是第一次请求的结果会覆盖掉第二次的请求结果，与预期不符
     **/
    let timer = 3000;
    function getData(data) {
        return new Promise((resolve,reject) => {
            setTimeout(() => {
                resolve(data)
            }, timer -= 1000)
        })
    }
    // 1. 手动解决方案
    // let arr = []
    // watch(() => state.name, async function(newValue) {
    //     // let r = await getData(newValue);
    //     // app.innerHTML = r; 
    //     let flag = true;
    //     while (arr.length) {
    //         let cb = arr.shift()
    //         cb()
    //     }
    //     arr.push(() => {    // 这个函数是个闭包
    //         flag = false;
    //     })
    //     let r = await getData(newValue);
    //     if(flag) {
    //         app.innerHTML = r
    //     }
    // })
    // 2. 使用 cleanup 解决
    watch(() => state.name, async function(newValue, oldValue, onCleanup) {
        let flag = true;
        // 这个函数是个【闭包】，会修改上一次的flag为false，导致上一次的结果不会执行下面的 app.innerHTML = r
        onCleanup(() => {    
            flag = false;
        })
        let r = await getData(newValue);
        if(flag) {
            app.innerHTML = r
        }
    })
    state.name = 1
    state.name = 2
</script>
```
onCleanup 的实现：
```js
function doWatch(source, cb, { immediate } = {} as any) {
  let getter;
  if (isReactive(source)) {
    getter = () => traverse(source);
  } else if (isFunction(source)) {
    getter = source;
  }
  let oldValue;
  let cleanup;
  function onCleanup(userCb) {
    cleanup = userCb;
  }
  const job = () => {
    // 2.1. 如果是watch API，在 scheduler 中调用 cb
    if (cb) {
      let newValue = effect.run();
      // watch的回调函数入参中如果存在cleanup，优先执行cleanup
      if (cleanup) {
        cleanup();
      }
      cb(newValue, oldValue, onCleanup);
      oldValue = newValue;
    } else {
      // 2.2. 如果是 watchEffect API，在 scheduler 中再次执行 effect.run
      effect.run();
    }
  };
  const effect = new ReactiveEffect(getter, job);
  if (immediate) {
    return job();
  }
  oldValue = effect.run();
}
```

## ref && toRef && toRefs && proxyRefs
### ref
```js
import { isObject } from "@vue/shared";
import { reactive } from "./reactive";
import { activeEffect, trackEffects, triggerEffects } from "./effect";

export function ref(value) {
  return new RefImpl(value);
}

function toReactive(value) {
  return isObject(value) ? reactive(value) : value;
}
class RefImpl {
  dep = undefined;
  _value;
  __v_isRef = true;
  constructor(public rawValue) {
    // 如果 ref 传入的是对象，则用reactive将它变成响应式的
    this._value = toReactive(rawValue);
  }
  get value() {
    // 依赖收集
    if (activeEffect) {
      trackEffects(this.dep || (this.dep = new Set()));
    }
    return this._value;
  }
  set value(newValue) {
    if (newValue !== this.rawValue) {
      // 更新数据：newValue 也需要用 toReactive 进行处理
      this._value = toReactive(newValue);
      this.rawValue = newValue;
      // 触发effect更新
      triggerEffects(this.dep);
    }
  }
}
```

### toRef
`toRef` 本质上就是一个代理，以 `let name = toRef(person,'name')` 为例，它是通过 class 的 `get` 和 `set` 将 `name.value` 代理到 `person.name`；
```js
export function toRef(target, key) {
  return new ObjectRefImpl(target, key);
}
class ObjectRefImpl {
  __v_isRef = true;
  constructor(public _object, public _key) {}
  get value() {
    return this._object[this._key];
  }
  set value(newValue) {
    this._object[this._key] = newValue;
  }
}
```

### toRefs
`toRefs` 本质是遍历对象，对每一个属性使用 `toRef` 进行代理，使得解构之后的对象属性仍具有响应式。
```js
export function toRefs(object) {
  const ret = {};
  for (let key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
```

### proxyRefs
用户在模板中使用 `ref` 数据不用手动添加 `.value` 的原因就是内部会将数据用 `proxyRefs` 做处理。
`proxyRefs` 用 `Proxy` 代理一个对象
1. 如果对象属性是 Ref 类型，则将 `get` 和 `set` 都代理到该属性的 `.value` 属性上
2. 如果对象属性不是 Ref 类型，则正常取值和设值

```js
export function proxyRefs(objectWithRefs) {
  return new Proxy(objectWithRefs, {
    get(target, key, receiver) {
      let v = Reflect.get(target, key, receiver);
      return v.__v_isRef ? v.value : v;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      if (oldValue.__v_isRef) {
        oldValue.value = value;
        return true;
      }
      return Reflect.set(target, key, value, receiver);
    },
  });
}
```

## effectScope
effectScope 用于创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即**计算属性**和**侦听器**)，这样捕获到的副作用可以一起处理。
特征：
1. 通过 `effectScope()` 创建一个作用域
2. 通过 `scope.run()` 执行回调，并收集内部的 effect 副作用
3. scope 内部可以嵌套 scope
4. 通过 `scope.stop()` 可以执行所有收集的 `effect.stop()`，并执行内部嵌套的非独立scope的 `effect.stop()`

```js
// effectScope.ts
export let activeEffectScope;
class EffectScope {
  active = true;
  effects = []; // 用来收集scope内部的effects
  parent; // 通过 parent 处理 effectScope 嵌套的情况
  scopes; // 嵌套scope时，用来收集内层的scope
  constructor(detached = false) {
    // 收集内层非独立的 scope
    if (!detached && activeEffectScope) {
      (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this);
    }
  }
  run(fn) {
    if (this.active) {
      try {
        this.parent = activeEffectScope;
        // 执行run时，将当前的effectScope放到全局的activeEffectScope，方便在创建内部的effect时，取到effectScope，并收集内部的effect
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = this.parent;
        this.parent = null; // 垃圾回收
      }
    }
  }
  stop() {
    if (this.active) {
      this.effects.forEach((effect) => {
        effect.stop(); // 遍历 effectScope 收集的effects，执行它们的 stop 方法
      });
    }
    // 嵌套时，收集的内层 scope 也需要执行 stop
    if (this.scopes) {
      this.scopes.forEach((scope) => {
        scope.stop();
      });
    }
    this.active = false;
  }
}

// 在effectScope.effects中收集相关的effectScope.run 内部的 effect
export function recordEffectScope(effect) {
  if (activeEffectScope && activeEffectScope.active) {
    activeEffectScope.effects.push(effect);
  }
}

export function effectScope(detached) {
  return new EffectScope(detached);
}
```
创建 effect 时，执行 `recordEffectScope`，在 `activeEffectScope` 中收集相关的 `effect`：
```js
// effect.ts
export class ReactiveEffect {
    // ...
    constructor(public fn, public scheduler) {
        // 在 effectScope 内如果创建了 effect，会将该 effect 收集到 effectScope.effects 中
        recordEffectScope(this);
    }
    // ...
}
```