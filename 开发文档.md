## Vue3 与 Vue2 的区别介绍
Vue3新增设计：
+ **模块拆分**：Vue3 源码采用 menorepo 方式进行管理，将模块拆分到 packages 中
+ Vue3 采用 **TS** 开发，增强类型检测。Vue2 采用 flow
+ Vue3 的性能优化，支持 **Tree-Shaking** ，不使用就不会打包
+ 允许**自定义渲染器**，扩展能力强。
+ Vue3 后期引入 **RFC**（Request For Comments 意即“请求评论”），使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)，记录了很多基于讨论实现的功能

Vue3 内部代码优化：
+ Vue2 采用 `defineProperty` 进行对象的数据劫持，有性能问题和缺陷；**Vue3 采用 `Proxy` 进行数据劫持**。
+ **Vue3 中对模板编译进行了优化**，编译时生成了 Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点
+ **Vue3 采用 composition API 进行组织功能**，解决反复横跳，优化逻辑复用（优化 `mixin` 带来的数据来源不清晰、命名冲突等），相比 options API 类型推断更加方便
+ **Vue3 增加了 `Fragment`、`Teleport`、`Suspense` 组件**

## Vue3 架构分析
### 1. Monorepo 介绍
`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库（repo）中管理多个包/模块（packages）。
+ 一个仓库可以维护多个模块，不用到处找仓库
+ 方便版本管理和依赖管理，模块之间的引用，调用都非常方便

> 缺点：仓库体积会变大

### 2. Vue3 项目结构
在 [vue3源码](https://github.com/vuejs/core/tree/main) 中可以看到，`packages`中一共有十几个模块：
+ `reactivity`：响应式系统
+ `runtime-core`：与平台无关的运行时核心（可以创建针对特定平台的运行时 - 自定义渲染器）
+ `runtime-dom`：针对浏览器的运行时（包括 DOM API、属性、事件等）
+ `runtime-test`：用于测试的运行时
+ `server-renderer`：用于服务端渲染
+ `compiler-core`：与平台无关的编译器核心
+ `compiler-dom`：针对浏览器的编译模块
+ `compiler-ssr`：针对服务端渲染的编译模块
+ `compiler-sfc`：针对单文件解析
+ `size-check`：用来测试代码体积
+ `template-explorer`：用于调试编译器输出的开发工具
+ `shared`：多个包之间共享的内容
+ `vue`：完整版本，包括浏览器的运行时和编译器
+ ...

`vue` 包的核心模块如下：
```
                          +-------------------+
                          |                   |
                          | @vue/compiler-sfc |
                          |                   |
                          +-----+--------+----+
                                |        |
                                v        v
              +-------------------+    +--------------------+
              |                   |    |                    |
     +------->| @vue/compiler-dom +--->| @vue/compiler-core |
     |        |                   |    |                    |
+----+----+   +-------------------+    +--------------------+
|         |
|   vue   |
|         |
+----+----+   +------------------+    +-------------------+    +-----------------+
     |        |                  |    |                   |    |                 |
     +------->| @vue/runtime-dom +--->| @vue/runtime-core +--->| @vue/reactivity |
              |                  |    |                   |    |                 |
              +------------------+    +-------------------+    +-----------------+
```

## 搭建开发环境
1. 创建文件夹 `mini-vue3-zf-pnpm`，并初始化项目
    ```
    pnpm init
    ```
2. 创建 `packages/reactivity/src/index.ts`、`packages/shared/src/index.ts` 两个文件夹
3. 创建 `.npmrc` 配置文件
    ```shell
    # pnpm安装vue时，默认不会将vue依赖的包展平到 node_modules 下，导致项目中无法使用vue的依赖
    # 通过以下配置将 vue 依赖的包展平到 node_modules 下
    shamefully-hoist = true
    ```
4. 创建 `pnpm-workspace.yaml`，定义工作空间的根目录
   ```yaml
   packages:
    - "packages/*"
   ```
5. 安装 `esbuild`、`typescript`、`minimist`（` minimist` 是一个专门用于处理Node.js启动参数的库）
   ```
   pnpm install esbuild typescript minimist -D -w
   ```
6. 初始化 typescript 配置文件
   ```
   pnpm tsc --init
   ```
   ```json
    {
        "compilerOptions": {
            "outDir": "dist", // 输出的目录
            "sourceMap": true,  // 采用 sourcemap
            "target": "es2016", // 目标语法
            "module": "esnext", // 模块格式
            "moduleResolution": "node", // 解析模块的方式
            "strict": false,  // 严格模式
            "resolveJsonModule": true,  // 解析json模块
            "esModuleInterop": true,  // 允许通过es6语法引入 commonjs 模块
            "jsx": "preserve",  // jsx 不转义
            "lib": ["esnext", "dom"]  // 支持的类库：esnext和dom
        }
    }
   ```
7. 进入 reactivity 模块，初始化子项目
   ```
   cd packages
   cd reactivity
   pnpm init
   ```
   修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/reactivity",
        "version": "1.0.0",
        "description": "",
        "module": "dist/reactivity.esm-bundler.js",
        "unpkg": "dist/reactivity.global.js",
        "buildOptions": {
            "name": "VueReactivity",
            "formats": [
                "esm-browser",
                "esm-bundler",
                "cjs",
                "global"
            ]
        }
    }
   ```
   > formats 为自定义的需要打包的格式：
   > + `global`：立即执行函数的格式，会暴露全局对象
   > + `esm-browser`：在浏览器中使用的格式，内联所有的依赖项
   > + `esm-bundler`：在构建工具中使用的格式，不提供 `.prod` 格式，在构建应用程序时会被构建工具一起进行打包压缩
   > + `cjs`：在node中使用的格式，例如服务端渲染
8. 同理，也进入 shared 模块，修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/shared",
        "version": "1.0.0",
        "module": "dist/shared.esm-bundler.js",
        "buildOptions": {
            "formats": [
                "esm-bundler",
                "cjs"
            ]
        }
    }
   ```
9. 在 `reactivity` 模块安装 `shared` 模块的依赖：
    ```
    pnpm install @vue/shared@workspace --filter @vue/reactivity
    ```
10. 在 `tsconfig.json` 中配置路径别名：
    ```json
    "baseUrl": ".",
    "paths": {
      "@vue/*": ["packages/*/src"]
    }
    ```
11. 对模块进行打包
    + 在根`package.json`中添加命令：`"dev": "node scripts/dev.js reactivity -f esm"`
    + 创建 `scripts/dev.js`：
        ```js
        const { build } = require("esbuild");
        const path = require("path");
        const args = require("minimist")(process.argv.slice(2)); // { _: [ 'reactivity' ], f: 'esm' }

        // 打包的模块是哪个
        const target = args._[0] || "reactivity";
        // 打包的格式是什么
        const format = args.f || "global";
        // 读取模块的 package.json 文件
        const pkg = require(path.resolve(
            __dirname,
            `../packages/${target}/package.json`
        ));
        // 输出格式：把 global 改成 iife
        const outputFormat = format.startsWith("global")
            ? "iife"
            : format === "cjs"
            ? "cjs"
            : "esm";
        // 输出的路径
        const outfile = path.resolve(
            __dirname,
            `../packages/${target}/dist/${target}.${format}.js`
        );

        // 使用esbuild打包
        build({
            entryPoints: [path.resolve(__dirname, `../packages/${target}/src/index.ts`)], // 入口
            outfile, // 出口
            bundle: true, // 是否打包到一起
            sourcemap: true, // 是否生成sourcemap文件（.map 结尾）
            format: outputFormat, // 打包的格式
            globalName: pkg.buildOptions?.name, // 打包的全局名称
            platform: format === "cjs" ? "node" : "browser", // 平台
            watch: {
                // 监控文件变化
                onRebuild(error) {
                if (!error) {
                    console.log("rebuild~~~");
                }
                },
            },
        }).then(() => {
            console.log("watching~~~");
        });
        ```

## 响应式
### reactive
```js
// reactive.ts
import { isObject } from "@vue/shared";
import { mutableHandlers } from "./baseHandlers";
export const enum ReactiveFlags {
    IS_REACTIVE = "__v_isReactive",
}
const reactiveMap = new WeakMap(); // 使用 WeakMap 防止内存泄漏
export function reactive(target) {
    // 1. reactive 只代理对象
    if (!isObject(target)) {
        return target;
    }
    // 2. 如果已经被代理过，则直接返回
    // 取 target[ReactiveFlags.IS_REACTIVE] 时，如果target已经被代理过，则会走到get函数，返回true
    if (target[ReactiveFlags.IS_REACTIVE]) {
        return target;
    }
    // 3. 不重复代理同一对象
    const existProxy = reactiveMap.get(target);
    if (existProxy) {
        return existProxy;
    }
    // 4. 创建代理
    const proxy = new Proxy(target, mutableHandlers);
    reactiveMap.set(target, proxy); // target -> proxy 的映射表
    return proxy;
}
```
```js
// baseHandlers.ts
import { ReactiveFlags } from "./reactive";
export const mutableHandlers = {
    // receiver 是当前的代理对象
    get(target, key, receiver) {
        // 通过下列判断，解决不重复代理已经经过代理的对象
        if (ReactiveFlags.IS_REACTIVE === key) {
            return true;
        }
        /**
        * 【问题描述】为何不能直接通过 target[key] 取值？
        * 现有一个对象person：
        * let person = {
        *    name: 'jw',
        *    get aliasName() {
        *        return 'alias' + this.name
        *    }
        * }
        * 当通过 person.aliasName 取值时，内部的 this.name （this指向person）是通过 person.name 读取的，不会触发响应式；
        * 而改成 Reflect.get(target, key, receiver) 后，this 指向 receiver，this.name 即 personProxy.name，依然会触发响应式；
        */
        track(target, key);
        return Reflect.get(target, key, receiver); // 【使用 Reflect.get 处理了 target 内部的 this 指向问题】
    },
    set(target, key, value, receiver) {
        let oldValue = target[key];
        const r = Reflect.set(target, key, value, receiver); // Reflect.set 返回一个boolean值
        if (oldValue !== value) {
            trigger(target, key, value, oldValue);
        }
        return r;
    },
};
```

### effect && cleanupEffect
```js
function cleanupEffect(effect) {
  // 每次执行effect之前，都应该将该effect从deps所有属性的dep中清理出去，以及清空effect的deps数组
  let { deps } = effect;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
export let activeEffect;
export class ReactiveEffect {
  public fn;
  public active = true;
  public deps = [];
  public parent = undefined;
  constructor(fn) {
    this.fn = fn;
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    // 通过设置parent属性，确保在嵌套effect中activeEffect的准确性
    try {
      this.parent = activeEffect;
      activeEffect = this;
      /**
       * 【意料之外的重新渲染】：每次触发 trigger 重新执行effect.run()，此时effect的依赖项可能发生变化（可能会删除之前的依赖或新增新的依赖），如果之前的依赖被删掉了，那么就需要清除之前收集的依赖，不然当该依赖变化时会重新执行effect，与预期不符。
       * 【解决方式】：在run中执行fn之前，先清除 effect.deps 中所有dep对应的effect，然后执行fn，会重新进行依赖收集
       */
      cleanupEffect(this);
      return this.fn(); // 执行fn的时候就会取值，取值的时候收集当前的activeEffect
    } finally {
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
}

export function effect(fn) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();
}
```

### track
```js
// 双向依赖收集
const targetMap = new WeakMap();
export function track(target, key) {
  // 1. 如果取值操作没有发生在effect中，直接返回，不会进行依赖收集
  if (!activeEffect) {
    return;
  }
  // 2. 从映射表中读取属性对应的dep
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  let shouldTrack = !dep.has(activeEffect);
  // 3. 双向收集：一个属性可能对应多个effect，一个effect可能对应多个属性
  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
```

### trigger
```js
export function trigger(target, key, newValue, oldValue) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep = depsMap.get(key);
  if (dep) {
    const effects = [...dep];
    // 执行dep中所有effect的run方法
    effects.forEach((effect) => {
      /**
       * 【问题描述】如果在effect内部修改依赖，会触发effect重新执行，造成死循环；
       * effect(() => {
       *  state.age = Math.random();  // 在effect内部修改state，如果此时重新执行当前的activeEffect，会造成死循环
       *  app.innerHTML = state.age
       * })
       * 所以重新执行effect时需要判断重新执行的effect是否是当前的activeEffect，如果是当前的activeEffect，则不重新执行
       */
      if (activeEffect !== effect) {
        effect.run();
      }
    });
  }
}
```

## gitEmoji
