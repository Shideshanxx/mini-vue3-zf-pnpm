## Vue3 与 Vue2 的区别介绍
Vue3新增设计：
+ **模块拆分**：Vue3 源码采用 menorepo 方式进行管理，将模块拆分到 packages 中
+ Vue3 采用 **TS** 开发，增强类型检测。Vue2 采用 flow
+ Vue3 的性能优化，支持 **Tree-Shaking** ，不使用就不会打包
+ 允许**自定义渲染器**，扩展能力强。
+ Vue3 后期引入 **RFC**（Request For Comments 意即“请求评论”），使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)，记录了很多基于讨论实现的功能

Vue3 内部代码优化：
+ Vue2 采用 `defineProperty` 进行对象的数据劫持，有性能问题和缺陷；**Vue3 采用 `Proxy` 进行数据劫持**。
+ **Vue3 中对模板编译进行了优化**，编译时生成了 Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点
+ **Vue3 采用 composition API 进行组织功能**，解决反复横跳，优化逻辑复用（优化 `mixin` 带来的数据来源不清晰、命名冲突等），相比 options API 类型推断更加方便
+ **Vue3 增加了 `Fragment`、`Teleport`、`Suspense` 组件**

## Vue3 架构分析
### 1. Monorepo 介绍
`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库（repo）中管理多个包/模块（packages）。
+ 一个仓库可以维护多个模块，不用到处找仓库
+ 方便版本管理和依赖管理，模块之间的引用，调用都非常方便

> 缺点：仓库体积会变大

### 2. Vue3 项目结构
在 [vue3源码](https://github.com/vuejs/core/tree/main) 中可以看到，`packages`中一共有十几个模块：
+ `reactivity`：响应式系统
+ `runtime-core`：与平台无关的运行时核心（可以创建针对特定平台的运行时 - 自定义渲染器）
+ `runtime-dom`：针对浏览器的运行时（包括 DOM API、属性、事件等）
+ `runtime-test`：用于测试的运行时
+ `server-renderer`：用于服务端渲染
+ `compiler-core`：与平台无关的编译器核心
+ `compiler-dom`：针对浏览器的编译模块
+ `compiler-ssr`：针对服务端渲染的编译模块
+ `compiler-sfc`：针对单文件解析
+ `size-check`：用来测试代码体积
+ `template-explorer`：用于调试编译器输出的开发工具
+ `shared`：多个包之间共享的内容
+ `vue`：完整版本，包括浏览器的运行时和编译器
+ ...

`vue` 包的核心模块如下：
```
                          +-------------------+
                          |                   |
                          | @vue/compiler-sfc |
                          |                   |
                          +-----+--------+----+
                                |        |
                                v        v
              +-------------------+    +--------------------+
              |                   |    |                    |
     +------->| @vue/compiler-dom +--->| @vue/compiler-core |
     |        |                   |    |                    |
+----+----+   +-------------------+    +--------------------+
|         |
|   vue   |
|         |
+----+----+   +------------------+    +-------------------+    +-----------------+
     |        |                  |    |                   |    |                 |
     +------->| @vue/runtime-dom +--->| @vue/runtime-core +--->| @vue/reactivity |
              |                  |    |                   |    |                 |
              +------------------+    +-------------------+    +-----------------+
```

## 搭建开发环境
1. 创建文件夹 `mini-vue3-zf-pnpm`，并初始化项目
    ```
    pnpm init
    ```
2. 创建 `packages/reactivity/src/index.ts`、`packages/shared/src/index.ts` 两个文件夹
3. 创建 `.npmrc` 配置文件
    ```shell
    # pnpm安装vue时，默认不会将vue依赖的包展平到 node_modules 下，导致项目中无法使用vue的依赖
    # 通过以下配置将 vue 依赖的包展平到 node_modules 下
    shamefully-hoist = true
    ```
4. 创建 `pnpm-workspace.yaml`，定义工作空间的根目录
   ```yaml
   packages:
    - "packages/*"
   ```
5. 安装 `esbuild`、`typescript`、`minimist`（` minimist` 是一个专门用于处理Node.js启动参数的库）
   ```
   pnpm install esbuild typescript minimist -D -w
   ```
6. 初始化 typescript 配置文件
   ```
   pnpm tsc --init
   ```
   ```json
    {
        "compilerOptions": {
            "outDir": "dist", // 输出的目录
            "sourceMap": true,  // 采用 sourcemap
            "target": "es2016", // 目标语法
            "module": "esnext", // 模块格式
            "moduleResolution": "node", // 解析模块的方式
            "strict": false,  // 严格模式
            "resolveJsonModule": true,  // 解析json模块
            "esModuleInterop": true,  // 允许通过es6语法引入 commonjs 模块
            "jsx": "preserve",  // jsx 不转义
            "lib": ["esnext", "dom"]  // 支持的类库：esnext和dom
        }
    }
   ```
7. 进入 reactivity 模块，初始化子项目
   ```
   cd packages
   cd reactivity
   pnpm init
   ```
   修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/reactivity",
        "version": "1.0.0",
        "description": "",
        "module": "dist/reactivity.esm-bundler.js",
        "unpkg": "dist/reactivity.global.js",
        "buildOptions": {
            "name": "VueReactivity",
            "formats": [
                "esm-browser",
                "esm-bundler",
                "cjs",
                "global"
            ]
        }
    }
   ```
   > formats 为自定义的需要打包的格式：
   > + `global`：立即执行函数的格式，会暴露全局对象
   > + `esm-browser`：在浏览器中使用的格式，内联所有的依赖项
   > + `esm-bundler`：在构建工具中使用的格式，不提供 `.prod` 格式，在构建应用程序时会被构建工具一起进行打包压缩
   > + `cjs`：在node中使用的格式，例如服务端渲染
8. 同理，也进入 shared 模块，修改生成的 `package.json`：
   ```json
    {
        "name": "@vue/shared",
        "version": "1.0.0",
        "module": "dist/shared.esm-bundler.js",
        "buildOptions": {
            "formats": [
                "esm-bundler",
                "cjs"
            ]
        }
    }
   ```
9. 在 `reactivity` 模块安装 `shared` 模块的依赖：
    ```
    pnpm install @vue/shared@workspace --filter @vue/reactivity
    ```
10. 在 `tsconfig.json` 中配置路径别名：
    ```json
    "baseUrl": ".",
    "paths": {
      "@vue/*": ["packages/*/src"]
    }
    ```
11. 对模块进行打包
    + 在根`package.json`中添加命令：`"dev": "node scripts/dev.js reactivity -f esm"`
    + 创建 `scripts/dev.js`：
        ```js
        const { build } = require("esbuild");
        const path = require("path");
        const args = require("minimist")(process.argv.slice(2)); // { _: [ 'reactivity' ], f: 'esm' }

        // 打包的模块是哪个
        const target = args._[0] || "reactivity";
        // 打包的格式是什么
        const format = args.f || "global";
        // 读取模块的 package.json 文件
        const pkg = require(path.resolve(
            __dirname,
            `../packages/${target}/package.json`
        ));
        // 输出格式：把 global 改成 iife
        const outputFormat = format.startsWith("global")
            ? "iife"
            : format === "cjs"
            ? "cjs"
            : "esm";
        // 输出的路径
        const outfile = path.resolve(
            __dirname,
            `../packages/${target}/dist/${target}.${format}.js`
        );

        // 使用esbuild打包
        build({
            entryPoints: [path.resolve(__dirname, `../packages/${target}/src/index.ts`)], // 入口
            outfile, // 出口
            bundle: true, // 是否打包到一起
            sourcemap: true, // 是否生成sourcemap文件（.map 结尾）
            format: outputFormat, // 打包的格式
            globalName: pkg.buildOptions?.name, // 打包的全局名称
            platform: format === "cjs" ? "node" : "browser", // 平台
            watch: {
                // 监控文件变化
                onRebuild(error) {
                if (!error) {
                    console.log("rebuild~~~");
                }
                },
            },
        }).then(() => {
            console.log("watching~~~");
        });
        ```
12. 